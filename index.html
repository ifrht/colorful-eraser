<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Colorful Eraser (Renkli Silgi) - Resimden Renk Silme & Doldurma</title>
    <meta name="description" content="Free online magic eraser and flood fill tool. Remove colors or fill erased areas instantly. Ücretsiz resimden renk silme, arka plan temizleme ve boşluk doldurma aracı.">
    <meta name="keywords" content="renk silici, color remover, magic eraser, flood fill, boya kovası, background remover, arka plan silme, transparent png, şeffaf resim, online image editor">
    <meta name="author" content="Ferhat Inalkac">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://ifrht.github.io/colorful-eraser/" />

    <meta property="og:type" content="website">
    <meta property="og:site_name" content="Colorful Eraser">
    <meta property="og:title" content="Renkli Silgi / Colorful Eraser & Fill">
    <meta property="og:description" content="Resimlerinizdeki istenmeyen renkleri silin veya boşlukları boyayın. Tamamen ücretsiz ve tarayıcı tabanlı.">
    <meta property="og:url" content="https://ifrht.github.io/colorful-eraser/">
    
    <!-- Paylaşım görseli ayarları güncellendi -->
    <meta property="og:image" content="https://ifrht.github.io/colorful-eraser/preview.png">
    <meta property="og:image:width" content="1920">
    <meta property="og:image:height" content="957">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Renkli Silgi / Colorful Eraser">
    <meta name="twitter:description" content="Remove specific colors or fill areas instantly using this free AI-like tool. Hızlı, ücretsiz renk silici ve doldurucu.">
    <!-- Twitter görseli -->
    <meta name="twitter:image" content="https://ifrht.github.io/colorful-eraser/preview.png">

    <meta name="theme-color" content="#0f172a">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <link rel="icon" type="image/x-icon" href="favicon.ico">

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Colorful Eraser / Renkli Silgi",
      "url": "https://ifrht.github.io/colorful-eraser/",
      "description": "Browser-based tool to remove specific colors from images, create transparent backgrounds, and fill areas.",
      "applicationCategory": "DesignApplication",
      "operatingSystem": "Any",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "author": {
        "@type": "Person",
        "name": "Ferhat Inalkac"
      },
      "featureList": "Color Removal, Magic Eraser, Flood Fill, Transparent PNG Download, Tolerance Adjustment, Undo Functionality"
    }
    </script>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>

    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        body { font-family: 'Inter', sans-serif; touch-action: pan-x pan-y; }
        canvas { touch-action: none; }
    </style>
</head>
<body class="bg-slate-900 text-slate-100 overscroll-none">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useEffect, useCallback } = React;

        const translations = {
            en: {
                title: "Colorful Eraser",
                subtitle: "Upload, pick, erase or fill.",
                uploadTitle: "Upload Image",
                uploadDesc: "Tap to select an image",
                toolsTitle: "TOOLS",
                btnPick: "Pick Color",
                btnErase: "Eraser",
                btnFill: "Fill",
                targetColorLabel: "Target Color (To Erase)",
                fillColorLabel: "Fill Color (To Paint)",
                lblTolerance: "Tolerance",
                lblSize: "Brush Size",
                btnReset: "Reset",
                btnUndo: "Undo",
                btnDownload: "Download PNG",
                waitingTitle: "Waiting for Image",
                waitingDesc: "Use the panel to upload an image."
            },
            tr: {
                title: "Renkli Silgi",
                subtitle: "Yükle, seç, sil veya doldur.",
                uploadTitle: "Resim Yükle",
                uploadDesc: "Resim seçmek için dokun",
                toolsTitle: "ARAÇLAR",
                btnPick: "Renk Seç",
                btnErase: "Silgi",
                btnFill: "Doldur",
                targetColorLabel: "Silinecek Renk",
                fillColorLabel: "Doldurma Rengi",
                lblTolerance: "Tolerans",
                lblSize: "Fırça Boyutu",
                btnReset: "Sıfırla",
                btnUndo: "Geri Al",
                btnDownload: "İndir (PNG)",
                waitingTitle: "Resim Bekleniyor",
                waitingDesc: "Resim yüklemek için paneli kullanın."
            }
        };

        const Eraser = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m7 21-4.3-4.3c-1-1-1-2.5 0-3.4l9.6-9.6c1-1 2.5-1 3.4 0l5.6 5.6c1 1 1 2.5 0 3.4L13 21"/><path d="M22 21H7"/><path d="m5 11 9 9"/></svg>
        );
        const Pipette = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M2 22h20"/><path d="M10.29 2.29a2.83 2.83 0 0 1 4 4l-8.29 8.29a1 1 0 0 0-.3.71v2h2a1 1 0 0 0 .71-.3l8.29-8.29a2.83 2.83 0 0 1 4 4L7 22l-5-5 5.29-14.71z"/></svg>
        );
        const PaintBucket = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="m19 11-8-8-8.6 8.6a2 2 0 0 0 0 2.8l5.2 5.2c.8.8 2 .8 2.8 0L19 11Z"/><path d="m5 2 5 5"/><path d="M2 13h15"/><path d="M22 20a2 2 0 1 1-4 0c0-1.6 1.7-2.4 2-4 .3 1.6 2 2.4 2 4Z"/></svg>
        );
        const Upload = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>
        );
        const Download = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>
        );
        const RefreshCw = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>
        );
        const Undo = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74-2.74L3 12"/><path d="M3 5v7h7"/></svg>
        );
        const ImageIcon = ({ className }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><rect width="18" height="18" x="3" y="3" rx="2" ry="2"/><circle cx="9" cy="9" r="2"/><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21"/></svg>
        );
        const Globe = ({ className }) => (
             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><circle cx="12" cy="12" r="10"/><line x1="2" x2="22" y1="12" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1 4-10z"/></svg>
        );

        function App() {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            
            const [lang, setLang] = useState('en');
            const t = translations[lang];

            const [image, setImage] = useState(null);
            const [targetColor, setTargetColor] = useState('#ffffff');
            const [fillColor, setFillColor] = useState('#ff0000');
            const [tolerance, setTolerance] = useState(30);
            const [brushSize, setBrushSize] = useState(50);
            
            const [history, setHistory] = useState([]);
            
            const [mode, setMode] = useState('erase'); 
            const [isPicking, setIsPicking] = useState(false); 
            const [isDrawing, setIsDrawing] = useState(false);
            
            const [cursorPos, setCursorPos] = useState({ x: -100, y: -100 });
            const [canvasSize, setCanvasSize] = useState({ width: 0, height: 0 });

            useEffect(() => {
                document.documentElement.lang = lang;
                document.title = lang === 'tr' ? "Renkli Silgi - Online Renk Silici & Doldurucu" : "Colorful Eraser - Free Online Color Remover & Fill Tool";
            }, [lang]);

            useEffect(() => {
                const handleKeyDown = (e) => {
                    if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
                        e.preventDefault();
                        handleUndo();
                    }
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, [history]);

            const hexToRgb = (hex) => {
                const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                return result ? {
                    r: parseInt(result[1], 16),
                    g: parseInt(result[2], 16),
                    b: parseInt(result[3], 16)
                } : { r: 255, g: 255, b: 255 };
            };

            const rgbToHex = (r, g, b) => {
                return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
            };

            const saveHistory = () => {
                const ctx = canvasRef.current.getContext('2d');
                const w = canvasRef.current.width;
                const h = canvasRef.current.height;
                const imageData = ctx.getImageData(0, 0, w, h);
                
                setHistory(prev => {
                    const newHistory = [...prev, imageData];
                    if (newHistory.length > 10) {
                        return newHistory.slice(newHistory.length - 10);
                    }
                    return newHistory;
                });
            };

            const handleUndo = () => {
                if (history.length === 0 || !canvasRef.current) return;
                
                const ctx = canvasRef.current.getContext('2d');
                const lastState = history[history.length - 1];
                
                ctx.putImageData(lastState, 0, 0);
                
                setHistory(prev => prev.slice(0, -1));
            };

            const handleImageUpload = (e) => {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        let w = img.width;
                        let h = img.height;
                        const maxWidth = 2000; 
                        
                        if (w > maxWidth) {
                            const ratio = maxWidth / w;
                            w = maxWidth;
                            h = h * ratio;
                        }

                        setCanvasSize({ width: w, height: h });
                        setImage(img);
                        setHistory([]);
                        
                        setTimeout(() => {
                            const canvas = canvasRef.current;
                            if(canvas) {
                                canvas.width = w;
                                canvas.height = h;
                                const ctx = canvas.getContext('2d');
                                ctx.drawImage(img, 0, 0, w, h);
                            }
                        }, 50);
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            };

            const handleReset = () => {
                if (image && canvasRef.current) {
                    const ctx = canvasRef.current.getContext('2d');
                    ctx.clearRect(0, 0, canvasSize.width, canvasSize.height);
                    ctx.drawImage(image, 0, 0, canvasSize.width, canvasSize.height);
                    setHistory([]);
                }
            };

            const colorDistance = (r1, g1, b1, r2, g2, b2) => {
                return Math.sqrt(
                    Math.pow(r1 - r2, 2) +
                    Math.pow(g1 - g2, 2) +
                    Math.pow(b1 - b2, 2)
                );
            };

            const getCoordinates = (e, canvas) => {
                const rect = canvas.getBoundingClientRect();
                let clientX, clientY;

                if (e.changedTouches && e.changedTouches.length > 0) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else if (e.touches && e.touches.length > 0) {
                     clientX = e.touches[0].clientX;
                     clientY = e.touches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                const visualX = clientX - rect.left;
                const visualY = clientY - rect.top;
                
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const actualX = visualX * scaleX;
                const actualY = visualY * scaleY;

                return { visualX, visualY, actualX, actualY, scaleX };
            };

            const handlePointerMove = (e) => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const coords = getCoordinates(e, canvas);
                setCursorPos({ x: coords.visualX, y: coords.visualY });

                if (isDrawing && !isPicking) { 
                    if (mode === 'erase') {
                        eraseColor(coords.actualX, coords.actualY, coords.scaleX);
                    }
                }
            };

            const handlePointerDown = (e) => {
                setIsDrawing(true);
                const canvas = canvasRef.current;
                if (!canvas) return;
                
                const coords = getCoordinates(e, canvas);
                setCursorPos({ x: coords.visualX, y: coords.visualY });

                if (isPicking) {
                    pickColor(coords.actualX, coords.actualY);
                    setIsPicking(false); 
                } else if (mode === 'fill') {
                    saveHistory();
                    floodFill(Math.floor(coords.actualX), Math.floor(coords.actualY));
                } else {
                    saveHistory();
                    eraseColor(coords.actualX, coords.actualY, coords.scaleX);
                }
            };

            const handlePointerUp = () => {
                setIsDrawing(false);
            };

            const pickColor = (x, y) => {
                const ctx = canvasRef.current.getContext('2d');
                const pixel = ctx.getImageData(
                    Math.max(0, Math.min(x, canvasSize.width - 1)), 
                    Math.max(0, Math.min(y, canvasSize.height - 1)), 
                    1, 1
                ).data;
                const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);
                
                if (mode === 'erase') {
                    setTargetColor(hex);
                } else {
                    setFillColor(hex);
                }
            };

            const floodFill = (startX, startY) => {
                const ctx = canvasRef.current.getContext('2d');
                const w = canvasRef.current.width;
                const h = canvasRef.current.height;
                
                const imgData = ctx.getImageData(0, 0, w, h);
                const data = imgData.data;
                
                if (startX < 0 || startX >= w || startY < 0 || startY >= h) return;

                const startPos = (startY * w + startX) * 4;
                const startR = data[startPos];
                const startG = data[startPos + 1];
                const startB = data[startPos + 2];
                const startA = data[startPos + 3];

                const fillRGB = hexToRgb(fillColor);
                
                if (startR === fillRGB.r && startG === fillRGB.g && startB === fillRGB.b && startA === 255) return;

                const stack = [startPos];
                const visited = new Uint8Array(w * h); 
                
                const match = (currPos) => {
                    const r = data[currPos];
                    const g = data[currPos + 1];
                    const b = data[currPos + 2];
                    const a = data[currPos + 3];
                    
                    if (startA === 0 && a === 0) return true;
                    if ((startA === 0 && a !== 0) || (startA !== 0 && a === 0)) return false;

                    return colorDistance(r, g, b, startR, startG, startB) <= tolerance * 2;
                };

                while (stack.length > 0) {
                    const pos = stack.pop();
                    const pixelIndex = pos / 4;
                    
                    if (visited[pixelIndex]) continue;
                    visited[pixelIndex] = 1;

                    if (match(pos)) {
                        data[pos] = fillRGB.r;
                        data[pos + 1] = fillRGB.g;
                        data[pos + 2] = fillRGB.b;
                        data[pos + 3] = 255; 

                        const x = pixelIndex % w;
                        const y = Math.floor(pixelIndex / w);

                        if (x > 0) stack.push(pos - 4);
                        if (x < w - 1) stack.push(pos + 4);
                        if (y > 0) stack.push(pos - w * 4);
                        if (y < h - 1) stack.push(pos + w * 4);
                    }
                }
                
                ctx.putImageData(imgData, 0, 0);
            };

            const eraseColor = (mouseX, mouseY, scale) => {
                const ctx = canvasRef.current.getContext('2d');
                const targetRGB = hexToRgb(targetColor);
                
                const scaledBrushSize = brushSize * scale;
                const r = scaledBrushSize / 2;
                
                const startX = Math.max(0, Math.floor(mouseX - r));
                const startY = Math.max(0, Math.floor(mouseY - r));
                const endX = Math.min(canvasSize.width, Math.ceil(mouseX + r));
                const endY = Math.min(canvasSize.height, Math.ceil(mouseY + r));
                
                const w = endX - startX;
                const h = endY - startY;

                if (w <= 0 || h <= 0) return;

                const imgData = ctx.getImageData(startX, startY, w, h);
                const data = imgData.data;
                const rSquared = r * r;

                let pixelChanged = false;

                for (let i = 0; i < data.length; i += 4) {
                    const pxIndex = i / 4;
                    const pxX = startX + (pxIndex % w);
                    const pxY = startY + Math.floor(pxIndex / w);

                    const distSquared = Math.pow(pxX - mouseX, 2) + Math.pow(pxY - mouseY, 2);
                    if (distSquared > rSquared) continue;

                    const alpha = data[i + 3];
                    if (alpha === 0) continue;

                    const red = data[i];
                    const green = data[i + 1];
                    const blue = data[i + 2];
                    
                    const dist = colorDistance(red, green, blue, targetRGB.r, targetRGB.g, targetRGB.b);
                    
                    if (dist <= tolerance * 2) {
                        data[i + 3] = 0;
                        pixelChanged = true;
                    }
                }
                
                if (pixelChanged) {
                    ctx.putImageData(imgData, startX, startY);
                }
            };

            const handleDownload = () => {
                if (!canvasRef.current) return;
                const link = document.createElement('a');
                link.download = 'colorful-eraser-result.png';
                link.href = canvasRef.current.toDataURL('image/png');
                link.click();
            };

            const toggleLang = () => {
                setLang(prev => prev === 'en' ? 'tr' : 'en');
            };

            return (
                <div className="min-h-screen bg-slate-900 text-slate-100 font-sans selection:bg-blue-500 selection:text-white flex flex-col">
                    <header className="border-b border-slate-700 bg-slate-800/50 backdrop-blur-md sticky top-0 z-20 p-4 shrink-0">
                        <div className="max-w-6xl mx-auto flex items-center justify-between">
                            <div className="flex items-center gap-2">
                                <Eraser className="w-6 h-6 text-blue-400" />
                                <h1 className="text-lg md:text-xl font-bold bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">
                                    {t.title}
                                </h1>
                            </div>
                            
                            <div className="flex items-center gap-4">
                                <div className="text-xs text-slate-400 hidden sm:block">
                                    {t.subtitle}
                                </div>
                                <button 
                                    onClick={toggleLang}
                                    className="flex items-center gap-1.5 bg-slate-700 hover:bg-slate-600 px-3 py-1.5 rounded-full text-xs font-bold transition-colors border border-slate-600"
                                >
                                    <Globe className="w-3.5 h-3.5 text-blue-400" />
                                    <span className={lang === 'tr' ? 'text-white' : 'text-slate-400'}>TR</span>
                                    <span className="text-slate-500">|</span>
                                    <span className={lang === 'en' ? 'text-white' : 'text-slate-400'}>EN</span>
                                </button>
                            </div>
                        </div>
                    </header>

                    <main className="max-w-6xl mx-auto p-4 flex flex-col lg:flex-row gap-6 mt-4 flex-1 w-full">
                        
                        <div className="w-full lg:w-80 flex flex-col gap-6 order-2 lg:order-1 shrink-0">
                            
                            <div className="bg-slate-800 p-4 rounded-xl border border-slate-700 shadow-lg">
                                <h2 className="text-sm font-semibold text-slate-300 mb-3 flex items-center gap-2">
                                    <ImageIcon className="w-4 h-4" /> {t.uploadTitle}
                                </h2>
                                <label className="flex flex-col items-center justify-center w-full h-24 border-2 border-slate-600 border-dashed rounded-lg cursor-pointer hover:bg-slate-700/50 active:bg-slate-700 transition-colors group">
                                    <div className="flex flex-col items-center justify-center pt-2 pb-3">
                                        <Upload className="w-6 h-6 mb-2 text-slate-400 group-hover:text-blue-400" />
                                        <p className="text-xs text-slate-400 text-center px-2">
                                            {t.uploadDesc}
                                        </p>
                                    </div>
                                    <input type="file" className="hidden" accept="image/*" onChange={handleImageUpload} />
                                </label>
                            </div>

                            <div className="bg-slate-800 p-4 rounded-xl border border-slate-700 shadow-lg space-y-5">
                                
                                <div>
                                    <label className="text-xs font-bold text-slate-400 uppercase tracking-wider mb-2 block">{t.toolsTitle}</label>
                                    <div className="flex gap-2">
                                        <button
                                            onClick={() => { setMode('erase'); setIsPicking(false); }}
                                            className={`flex-1 py-3 px-2 rounded-lg transition-all flex items-center justify-center gap-2 text-sm font-medium ${
                                                mode === 'erase' && !isPicking
                                                    ? 'bg-rose-600 text-white shadow-lg shadow-rose-500/30' 
                                                    : 'bg-slate-700 text-slate-300'
                                            }`}
                                        >
                                            <Eraser className="w-4 h-4" /> {t.btnErase}
                                        </button>
                                        <button
                                            onClick={() => { setMode('fill'); setIsPicking(false); }}
                                            className={`flex-1 py-3 px-2 rounded-lg transition-all flex items-center justify-center gap-2 text-sm font-medium ${
                                                mode === 'fill' && !isPicking
                                                    ? 'bg-amber-500 text-white shadow-lg shadow-amber-500/30' 
                                                    : 'bg-slate-700 text-slate-300'
                                            }`}
                                        >
                                            <PaintBucket className="w-4 h-4" /> {t.btnFill}
                                        </button>
                                    </div>
                                </div>

                                <div>
                                    <div className={`flex items-center gap-3 bg-slate-700/50 p-2 rounded-lg border transition-colors duration-300 ${
                                        isPicking ? 'border-blue-500 ring-1 ring-blue-500/50' : 
                                        (mode === 'fill' ? 'border-amber-500/30' : 'border-rose-500/30')
                                    }`}>
                                        
                                        <button 
                                            onClick={() => setIsPicking(!isPicking)}
                                            className={`p-2 rounded-md transition-all ${
                                                isPicking 
                                                    ? 'bg-blue-500 text-white shadow-lg' 
                                                    : 'bg-slate-600 text-slate-300 hover:bg-slate-500'
                                            }`}
                                            title="Pick Color from Image"
                                        >
                                            <Pipette className="w-5 h-5" />
                                        </button>

                                        <div className="w-px h-8 bg-slate-600"></div>

                                        {mode === 'fill' ? (
                                            <>
                                                <input
                                                    type="color"
                                                    value={fillColor}
                                                    onChange={(e) => setFillColor(e.target.value)}
                                                    className="w-10 h-10 rounded cursor-pointer bg-transparent"
                                                />
                                                <div className="flex-1 overflow-hidden">
                                                    <div className="text-sm font-mono text-slate-300 truncate">{fillColor}</div>
                                                    <div className="text-[10px] text-amber-400">{t.fillColorLabel}</div>
                                                </div>
                                            </>
                                        ) : (
                                            <>
                                                <input
                                                    type="color"
                                                    value={targetColor}
                                                    onChange={(e) => setTargetColor(e.target.value)}
                                                    className="w-10 h-10 rounded cursor-pointer bg-transparent"
                                                />
                                                <div className="flex-1 overflow-hidden">
                                                    <div className="text-sm font-mono text-slate-300 truncate">{targetColor}</div>
                                                    <div className="text-[10px] text-rose-400">{t.targetColorLabel}</div>
                                                </div>
                                            </>
                                        )}
                                    </div>
                                    
                                    {isPicking && (
                                        <div className="text-[10px] text-blue-400 mt-1.5 text-center animate-pulse">
                                            {mode === 'erase' ? "Click on image to select color to ERASE" : "Click on image to select color to PAINT with"}
                                        </div>
                                    )}
                                </div>

                                <div className="space-y-4">
                                    <div>
                                        <div className="flex justify-between mb-2">
                                            <label className="text-xs font-bold text-slate-400 uppercase">{t.lblTolerance}</label>
                                            <span className="text-xs text-blue-400 font-mono">{tolerance}</span>
                                        </div>
                                        <input
                                            type="range"
                                            min="1"
                                            max="100"
                                            value={tolerance}
                                            onChange={(e) => setTolerance(Number(e.target.value))}
                                            className="w-full h-4 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-blue-500 touch-none"
                                        />
                                    </div>

                                    <div className={mode === 'fill' ? 'opacity-50 pointer-events-none' : ''}>
                                        <div className="flex justify-between mb-2">
                                            <label className="text-xs font-bold text-slate-400 uppercase">{t.lblSize}</label>
                                            <span className="text-xs text-rose-400 font-mono">{brushSize}px</span>
                                        </div>
                                        <input
                                            type="range"
                                            min="5"
                                            max="100"
                                            value={brushSize}
                                            onChange={(e) => setBrushSize(Number(e.target.value))}
                                            className="w-full h-4 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-rose-500 touch-none"
                                        />
                                    </div>
                                </div>

                                <div className="pt-2 border-t border-slate-700 grid grid-cols-3 gap-2">
                                    <button
                                        onClick={handleUndo}
                                        disabled={history.length === 0}
                                        className="py-3 bg-slate-700 active:bg-slate-600 disabled:opacity-50 disabled:cursor-not-allowed text-slate-300 rounded-lg flex items-center justify-center gap-2 transition-colors text-xs font-medium"
                                        title="Ctrl+Z"
                                    >
                                        <Undo className="w-4 h-4" /> {t.btnUndo}
                                    </button>
                                    <button
                                        onClick={handleReset}
                                        disabled={!image}
                                        className="py-3 bg-slate-700 active:bg-slate-600 disabled:opacity-50 disabled:cursor-not-allowed text-slate-300 rounded-lg flex items-center justify-center gap-2 transition-colors text-xs font-medium"
                                    >
                                        <RefreshCw className="w-4 h-4" /> {t.btnReset}
                                    </button>
                                    <button
                                        onClick={handleDownload}
                                        disabled={!image}
                                        className="py-3 bg-green-600 active:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed text-white rounded-lg flex items-center justify-center gap-2 shadow-lg shadow-green-900/20 transition-all text-xs font-bold"
                                    >
                                        <Download className="w-4 h-4" /> {t.btnDownload}
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div 
                            ref={containerRef}
                            className={`flex-1 bg-slate-800 rounded-xl border border-slate-700 shadow-2xl overflow-hidden relative min-h-[400px] flex items-center justify-center order-1 lg:order-2 touch-none ${isPicking ? 'cursor-crosshair' : ''}`}
                        >
                            {!image && (
                                <div className="text-center p-8 select-none">
                                    <div className="w-20 h-20 bg-slate-700 rounded-full flex items-center justify-center mx-auto mb-4">
                                        <ImageIcon className="w-10 h-10 text-slate-500" />
                                    </div>
                                    <h3 className="text-lg font-semibold text-slate-300">{t.waitingTitle}</h3>
                                    <p className="text-slate-500 mt-2 text-sm">{t.waitingDesc}</p>
                                </div>
                            )}

                            <div className={`relative ${!image ? 'hidden' : 'block'}`}>
                                <canvas
                                    ref={canvasRef}
                                    style={{ touchAction: 'none' }} 
                                    onMouseDown={handlePointerDown}
                                    onMouseMove={handlePointerMove}
                                    onMouseUp={handlePointerUp}
                                    onMouseLeave={handlePointerUp}
                                    
                                    onTouchStart={handlePointerDown}
                                    onTouchMove={handlePointerMove}
                                    onTouchEnd={handlePointerUp}
                                    
                                    className="max-w-full h-auto shadow-lg bg-[url('https://media.istockphoto.com/id/1146311499/vector/checker-seamless-pattern-checkered-background-chess-squares-texture.jpg?s=612x612&w=0&k=20&c=L_Jj9n30i1lF-7qGj93HjEpskQ5lO3W5ZqVd_JzH2hE=')] bg-repeat touch-none"
                                />
                                
                                {image && (
                                    <div
                                        className="pointer-events-none fixed z-50 rounded-full border border-white shadow-sm mix-blend-difference flex items-center justify-center"
                                        style={{
                                            left: cursorPos.x + (canvasRef.current ? canvasRef.current.getBoundingClientRect().left : 0),
                                            top: cursorPos.y + (canvasRef.current ? canvasRef.current.getBoundingClientRect().top : 0),
                                            width: (isPicking) ? 0 : (mode === 'erase' ? brushSize : 20),
                                            height: (isPicking) ? 0 : (mode === 'erase' ? brushSize : 20),
                                            transform: 'translate(-50%, -50%)',
                                            display: cursorPos.x < 0 ? 'none' : 'flex'
                                        }}
                                    >
                                        {isPicking && <Pipette className="w-8 h-8 text-blue-500 drop-shadow-lg -translate-y-4 translate-x-4" />}
                                        {!isPicking && mode === 'erase' && <div className="w-full h-full bg-white rounded-full opacity-60"></div>}
                                        {!isPicking && mode === 'fill' && <div className="w-2 h-2 bg-amber-500 rounded-full shadow-lg ring-2 ring-white"></div>}
                                    </div>
                                )}
                            </div>
                        </div>

                    </main>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
